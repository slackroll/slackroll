#!/usr/bin/env python
# Author: Ricardo Garcia
# License: Public domain code
import anydbm
import cPickle
import cStringIO
import fcntl
import glob
import math
import operator
import os
import re
import shelve
import socket
import struct
import subprocess
import sys
import termios
import urllib
import urlparse

slackroll_version = 29

slackroll_exit_failure = 1
slackroll_exit_success = 0

slackroll_pkg_re = re.compile(r'^(.*/)?([^/]+)-([^/-]+)-([^/-]+)-([^/-]+?)(\.tgz)?$')
slackroll_pkg_re_path = 1
slackroll_pkg_re_name = 2
slackroll_pkg_re_version = 3
slackroll_pkg_re_arch = 4
slackroll_pkg_re_build = 5
slackroll_pkg_re_suffix = 6

slackroll_base_dir = os.path.join(os.path.sep, 'var', 'slackroll')
slackroll_default_temp_dir = os.path.join(slackroll_base_dir, 'tmp')
slackroll_pkgs_dir_glob = os.path.join(slackroll_base_dir, 'packages', '*')
slackroll_pkgs_dir = os.path.dirname(slackroll_pkgs_dir_glob)
slackroll_local_pkgs_glob = os.path.join(os.path.sep, 'var', 'log', 'packages', '*')
slackroll_local_pkgs_dir = os.path.dirname(slackroll_local_pkgs_glob)
slackroll_local_pkg_filelist_marker = 'FILE LIST:\n'
slackroll_filelist_pkg_re = re.compile(r'^-[rwx-]{9}\s+\d+\s+\w+\s+\w+\s+(\d+)\s+\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}\s+(\./.+/[^/]+-[^/-]+-[^/-]+-[^/-]+\.tgz)$')
slackroll_filelist_pkg_size = 1
slackroll_filelist_pkg_str = 2
slackroll_source_indicator = '/source/'
slackroll_pasture_indicator = '/pasture/'
slackroll_patch_indicator = '/patches/'
slackroll_main_indicator = '/slackware/'
slackroll_extra_indicator = '/extra/'
slackroll_prioritized_pkgs = ['glibc-solibs', 'sed', 'pkgtools']

slackroll_self_filename = os.path.join(slackroll_base_dir, 'self')
slackroll_mirror_filename = os.path.join(slackroll_base_dir, 'mirror')
slackroll_primary_mirror_filename = os.path.join(slackroll_base_dir, 'pmirror')
slackroll_persistentlist_filename = os.path.join(slackroll_base_dir, 'persistent.db')
slackroll_locallist_filename = os.path.join(slackroll_base_dir, 'local.db')
slackroll_remotelist_filename = os.path.join(slackroll_base_dir, 'remote.db')
slackroll_pkg_files_filename = os.path.join(slackroll_base_dir, 'pkgfiles.db')
slackroll_known_files = os.path.join(slackroll_base_dir, 'knownfiles.db')
slackroll_blacklist_filename = os.path.join(slackroll_base_dir, 'blacklist.db')
slackroll_filelist_filename = 'FILELIST.TXT'
slackroll_changelog_filename = 'ChangeLog.txt'
slackroll_changelog_entry_separator = '+--------------------------+\n'
slackroll_local_filelist = os.path.join(slackroll_base_dir, slackroll_filelist_filename)
slackroll_local_changelog = os.path.join(slackroll_base_dir, 'changelog.db')
slackroll_gpgkey_filename = 'GPG-KEY'
slackroll_local_gpgkey = os.path.join(slackroll_base_dir, slackroll_gpgkey_filename)
slackroll_temp_suffix = '.part'
slackroll_signature_suffix = '.asc'
slackroll_info_suffix = '.txt'
slackroll_new_suffix = '.new'
slackroll_pkg_archive_suffix = '.tgz'
slackroll_default_pager = 'less'
slackroll_default_visual = 'vim'
slackroll_default_difftool = 'vimdiff'
slackroll_gnupg_exec_names = ['gpg2', 'gpg']
slackroll_never_missing_re = re.compile(r'(^/install/)|(^/dev/)|(^/lib/incoming/)')

slackroll_state_new = 0
slackroll_state_unavailable = 1
slackroll_state_installed = 2
slackroll_state_notinstalled = 3
slackroll_state_frozen = 4
slackroll_state_foreign = 5
slackroll_state_outdated = 6
slackroll_state_strings = ['new', 'unavailable', 'installed', 'not-installed', 'frozen', 'foreign', 'outdated']
slackroll_transient_states = [slackroll_state_new, slackroll_state_outdated, slackroll_state_unavailable]
slackroll_all_states = [x for x in xrange(len(slackroll_state_strings))]

slackroll_socket_timeout = 120
slackroll_mirror_version_re = re.compile(r'/slackware-([^/]+)/')
slackroll_pb_location = 'http://packages.slackware.it/'
slackroll_pb_template_url = 'http://packages.slackware.it/search.php?v=%s&t=2&q=%s'
slackroll_pb_result_re = r'(?is)<div class="result">.*?<div class="pkgtitle">.*?<a[^>]*>(.+?)</a>.*?</div>.*?<div class="pkgdescr">(.+?)</div>.*?</div>'
slackroll_pb_result_idname = 1
slackroll_pb_result_files = 2
slackroll_default_primary_site_url = 'http://slackware.osuosl.org/slackware-%s/'

slackroll_locale_envvars = ['LC_COLLATE', 'LC_CTYPE', 'LC_MONETARY', 'LC_MESSAGES', 'LC_NUMERIC', 'LC_TIME', 'LC_ALL', 'LANGUAGE', 'LANG']
slackroll_locale_mainvar = 'LANG'
slackroll_locale_value = 'C'

def standarize_locales():
	for varname in slackroll_locale_envvars:
		if varname in os.environ:
			del os.environ[varname]
	os.environ[slackroll_locale_mainvar] = slackroll_locale_value

def index_of(thelist, elem):
	try:
		return thelist.index(elem)
	except ValueError:
		return -1

def pkg_name_cmp(name1, name2): # To be used for sorting functions
	idx1 = index_of(slackroll_prioritized_pkgs, name1)
	idx2 = index_of(slackroll_prioritized_pkgs, name2)

	if idx1 == -1:
		if idx2 == -1:
			return cmp(name1, name2)
		return 1
	if idx2 == -1:
		return -1
	return (idx1 - idx2)

def transient_cmp((name1, state1), (name2, state2)): # Special sort for transient list
	if name1 in slackroll_prioritized_pkgs or name2 in slackroll_prioritized_pkgs:
		return pkg_name_cmp(name1, name2)
	if state1 != state2:
		return (index_of(slackroll_transient_states, state1) - index_of(slackroll_transient_states, state2))
	return cmp(name1, name2)

class SlackRollError(Exception):
	pass

class SlackwarePackage(object):
	__name = None
	__version = None
	__arch = None
	__build = None
	__path = None
	__suffix = None
	__size = None

	def __init__(self, name, version, arch, build, path, suffix, size):
		self.__name = name
		self.__version = version
		self.__arch = arch
		self.__build = build
		self.__path = (path is not None and path or '')
		self.__suffix = (suffix is not None and suffix or '')
		self.__size = size

	def __eq__(self, other):
		return self.__name == other.__name and self.__version == other.__version and self.__arch == other.__arch and self.__build == other.__build

	@property
	def name(self):
		return self.__name

	@property
	def version(self):
		return self.__version

	@property
	def arch(self):
		return self.__arch

	@property
	def build(self):
		return self.__build

	@property
	def path(self):
		return self.__path

	@property
	def suffix(self):
		return self.__suffix

	@property
	def size(self):
		return self.__size

	@property
	def idname(self):
		return '%s-%s-%s-%s' % (self.__name, self.__version, self.__arch, self.__build)

	@property
	def archivename(self):
		return '%s%s' % (self.idname, slackroll_pkg_archive_suffix)

	@property
	def fullname(self):
		return os.path.join(self.path, '%s-%s-%s-%s%s' % (self.__name, self.__version, self.__arch, self.__build, self.__suffix))

	def __cmp__(self, other):
		return pkg_name_cmp(self.__name, other.__name)

	def local(self): # Returns the equivalent local pkg
		return SlackwarePackage(self.__name, self.__version, self.__arch, self.__build, slackroll_local_pkgs_dir, None, None)

	def url(self, mirror):
		return urlparse.urljoin(mirror, self.fullname)

class SlackRollURLopener(urllib.FancyURLopener):
	def http_error_default(self, url, fp, errcode, errmsg, headers):
		raise IOError('%s: %s' % (errcode, errmsg))

def pkg_from_str(path_or_name): # Create a SlackwarePackage object from a string
	return pkg_from_name_and_size(path_or_name, None)

def pkg_from_name_and_size(path_or_name, size_str): # Create a SlackwarePackage object from a name string and a size string
	matchobj = slackroll_pkg_re.match(path_or_name)

	if matchobj is None:
		raise SlackRollError('nonstandard package name: %s' % path_or_name)

	path = matchobj.group(slackroll_pkg_re_path)
	name = matchobj.group(slackroll_pkg_re_name)
	version = matchobj.group(slackroll_pkg_re_version)
	arch = matchobj.group(slackroll_pkg_re_arch)
	build = matchobj.group(slackroll_pkg_re_build)
	suffix = matchobj.group(slackroll_pkg_re_suffix)
	try:
		size = (size_str is not None and long(size_str) or None)
	except ValueError:
		raise SlackRollError('invalid file size: %s' % size_str)
	return SlackwarePackage(name, version, arch, build, path, suffix, size)

def pkg_in_map(pkg, map_by_name): # Checks if pkg is in map[pkg.name], usable for local_list and remote_list
	return pkg in map_by_name.get(pkg.name, [])

class ChangeLogEntry(object):
	_timestamp = None	# Entry timestamp
	_text = None		# Entry text

	def __init__(self, timestamp, text):
		self._timestamp = timestamp
		self._text = text
	
	@property
	def timestamp(self):
		return self._timestamp

	@property
	def text(self):
		return self._text

	def __eq__(self, other):
		return (self.timestamp == other.timestamp or self.text == other.text)

	def __str__(self):
		return '%s\n%s' % (self.timestamp, self.text)

class ChangeLog(object):
	_cur_batch = None
	_batches = None

	def __init__(self):
		self._cur_batch = 0
		self._batches = dict()
	
	def start_new_batch(self):
		self._cur_batch += 1
	
	def add_entry(self, entry):
		val = self._batches.get(self._cur_batch, [])
		val.append(entry)
		self._batches[self._cur_batch] = val
	
	def add_entries(self, entry_list):
		for x in entry_list:
			self.add_entry(x)
	
	def last_batch(self):
		return self._batches.get(self._cur_batch, [])

	def num_batches(self):
		return len(self._batches.keys())

	def get_batch(self, batchnum):
		return self._batches.get(batchnum, [])

def clentry_from_text(text):
	lines = text.split('\n')
	text = '\n'.join(lines[1:])
	timestamp = lines[0].strip()
	return ChangeLogEntry(timestamp, text)

def clentrylist_from_text(text):
	entries = text.split(slackroll_changelog_entry_separator)
	entries = [x for x in entries if len(x) > 0]
	return [clentry_from_text(x) for x in entries]

def print_flush(message):
	sys.stdout.write(message)
	sys.stdout.flush()

def concat(list_of_lists):
	return reduce(operator.concat, list_of_lists, [])

def get_env_or(varname, defval):
	value = os.getenv(varname)
	if value is None:
		return defval
	return value

def get_temp_dir(): # Temporary directory name
	return get_env_or('TMPDIR', slackroll_default_temp_dir)

def get_pager():
	return get_env_or('PAGER', slackroll_default_pager)

def get_visual():
	return get_env_or('VISUAL', slackroll_default_visual)

def get_difftool():
	return get_env_or('SRDIFF', slackroll_default_difftool)

def optimum_size_conversion(bytes):
	suffixes = 'bkMGTPEZY'
	if bytes == 0:
		suffidx = 0
	else:
		suffidx = min(int(math.log(bytes, 1024)), len(suffixes) - 1)
	if suffidx == 0:
		return '%s%s' % (bytes, suffixes[suffidx])
	return '%.1f%s' % (float(bytes) / (1024.0**suffidx), suffixes[suffidx])

def enough_fs_resources(numpkgs, bytes): # Check if there are enough filesystem resources to store the given number of packages and bytes
	fs_stats = os.statvfs(os.path.join(slackroll_base_dir, os.path.curdir))
	available_bytes = fs_stats.f_bfree * fs_stats.f_bsize
	return (available_bytes > bytes)

def get_self_file_version(): # Get self version from disk file
	try:
		data = file(slackroll_self_filename, 'r').read()
		return long(data)
	except (OSError, IOError, ValueError), err:
		sys.exit('ERROR: %s' % err)

def write_self_file_version(): # Write self version to disk file
	try:
		file(slackroll_self_filename, 'w').write('%s\n' % slackroll_version)
	except (OSError, IOError), err:
		sys.exit('ERROR: %s' % err)

def long_time_warning():
	print 'WARNING: This operation may take a long time to complete'

def interpret_results_warning():
	print 'WARNING: Results should be interpreted carefully'

def low_fs_resources_warning():
	print 'WARNING: Available disk space may not be enough'

def get_mtime(path):
	try:
		return os.path.getmtime(path)
	except (OSError, IOError), err:
		sys.exit('ERROR: %s' % err)

def newer_than(path1, path2): # path1 modification time more recent than path2 modification time?
	if not os.path.exists(path1) and not os.path.exists(path2):
		return True # Sane default response, according to the usage we make of this function
	if not os.path.exists(path1):
		return False
	if not os.path.exists(path2):
		return True
	reftime = get_mtime(path1)
	modtime = get_mtime(path2)
	return (reftime > modtime)
	
def is_readable_file(filepath):
	return os.path.isfile(filepath) and os.access(filepath, os.R_OK)

def try_dump(object, filepath): # cPickle.dump()
	try:
		cPickle.dump(object, file(filepath, 'wb'), -1)
	except (OSError, IOError, cPickle.PickleError), err:
		sys.exit('ERROR: %s' % err)

def try_load(filepath): # cPickle.load()
	try:
		return cPickle.load(file(filepath, 'rb'))
	except (OSError, IOError, cPickle.PickleError), err:
		sys.exit('ERROR: %s' % err)

def get_blacklist(): # Get blacklist expression list
	if is_readable_file(slackroll_blacklist_filename):
		return try_load(slackroll_blacklist_filename)
	return []

def get_blacklist_re(): # Almost the same, but already converted to regular expressions
	try:
		return [re.compile(x) for x in get_blacklist()]
	except re.error:
		sys.exit('ERROR: invalid regular expression found in blacklist')

def add_blacklist_exprs(expressions): # Add expressions to the blacklist
	valid_ones = []
	for regex_str in expressions:
		try:
			re.compile(regex_str)
			valid_ones.append(regex_str)
		except re.error:
			sys.exit('ERROR: "%s" is an invalid regular expression' % regex_str)
	bl = get_blacklist()
	bl.extend(valid_ones)
	try_dump(bl, slackroll_blacklist_filename)

def del_blacklist_exprs(indexes): # Remove expressions from the blacklist
	bl = get_blacklist()
	idnums = []
	for idx in indexes:
		try:
			num = long(idx)
			if num < 0 or num >= len(bl):
				raise ValueError()
			idnums.append(num)
		except ValueError:
			sys.exit('ERROR: invalid blacklist entry index: %s' % idx)
	index_regex_pairs = [(x, bl[x]) for x in xrange(len(bl))]
	newbl = [regex for (idx, regex) in index_regex_pairs if idx not in idnums]
	try_dump(newbl, slackroll_blacklist_filename)

def print_blacklist():
	bl = get_blacklist()
	numbered = ['%-4s  %s' % (x, bl[x]) for x in xrange(len(bl))]
	print_list_or(numbered, 'Blacklisted expressions:', 'No blacklisted expressions')

def extract_file_list(filename): # Extracts the file list from a local info file
	try:
		lines = file(filename, 'r').readlines()
		paths = ['/%s' % x.strip().decode('string_escape') for x in lines[lines.index(slackroll_local_pkg_filelist_marker) + 1:]]
		return paths
	except ValueError:
		sys.exit('ERROR: unable to find file list marker in %s' % filename)
	except (OSError, IOError), err:
		sys.exit('ERROR: %s' % err)

def get_pkg_filelists(): # Return a dictionary of filename->filelist from /var/log/packages
	if newer_than(slackroll_local_pkgs_dir, slackroll_pkg_files_filename):
		try:
			filenames = glob.glob(slackroll_local_pkgs_glob)
		except (OSError, IOError), err:
			sys.exit('ERROR: %s' % err)
		contents = dict()
		for filename in filenames:
			contents[filename] = extract_file_list(filename)
		try_dump(contents, slackroll_pkg_files_filename)
	return try_load(slackroll_pkg_files_filename)

def get_normalized_known_files(): # Return a set of known files for orphan-search
	if newer_than(slackroll_local_pkgs_dir, slackroll_known_files):
		try:
			filenames = glob.glob(slackroll_local_pkgs_glob)
		except (OSError, IOError), err:
			sys.exit('ERROR: %s' % err)
		known_files = set()
		for pkg in filenames:
			for path in extract_file_list(pkg):
				known_files.add(os.path.realpath(path))
		try_dump(known_files, slackroll_known_files)
	return try_load(slackroll_known_files)

def get_local_pkgs(): # Return a list of packages from /var/log/packages
	local_pkgs = glob.glob(slackroll_local_pkgs_glob)
	if len(local_pkgs) == 0:
		sys.exit('ERROR: could not read list of local packages')
	try:
		local_pkgs = [pkg_from_str(x) for x in local_pkgs]
	except SlackRollError, err:
		sys.exit('ERROR: %s' % err)
	return local_pkgs

def get_local_list(forced_rebuild): # Return list of local packages from cached list, updating it if needed
	if newer_than(slackroll_local_pkgs_dir, slackroll_locallist_filename) or forced_rebuild:
		print 'Rebuilding local package list...'
		dupes = set()
		local_list = dict()
		for pkg in get_local_pkgs():
			name = pkg.name
			if name in local_list:
				dupes.add(name)
			value = local_list.get(name, [])
			value.append(pkg)
			local_list[name] = value
		if len(dupes) > 0:
			print 'WARNING: packages with two or more local versions should be frozen or foreign'
			print_seq(dupes, 'WARNING: list of packages with two or more local versions:')
		try_dump(local_list, slackroll_locallist_filename)
	return try_load(slackroll_locallist_filename)

def get_remote_pkgs(): # Return a list of packages from FILELIST.TXT
	try:
		lines = file(slackroll_local_filelist, 'r').readlines()
		matches = [slackroll_filelist_pkg_re.match(x) for x in lines]
		nm_sz = [(x.group(slackroll_filelist_pkg_str), x.group(slackroll_filelist_pkg_size)) for x in matches if x is not None]
		return [pkg_from_name_and_size(nm, sz) for (nm, sz) in nm_sz if slackroll_source_indicator not in nm]
	except (OSError, IOError), err:
		sys.exit('ERROR: %s' % err)

def get_remote_list(forced_rebuild): # Return list of remote packages from cached list, updating if needed
	bl = get_blacklist_re()
	if (newer_than(slackroll_local_filelist, slackroll_remotelist_filename)
	    or newer_than(slackroll_blacklist_filename, slackroll_remotelist_filename)
	    or forced_rebuild):
		print 'Rebuilding remote packages list...'
		remote_list = dict()
		has_patch = set()
		for pkg in get_remote_pkgs():
			# Ignore packages matching blacklist
			fullname = pkg.fullname
			matches = [x.search(fullname) for x in bl]
			if len([x for x in matches if x is not None]) > 0:
				continue
			# Mark packages with patches
			name = pkg.name
			if slackroll_patch_indicator in pkg.path:
				has_patch.add(name)
			value = remote_list.get(name, [])
			value.append(pkg)
			remote_list[name] = value
		# Remove unpatched versions
		for name in has_patch:
			if any_in_main_tree(remote_list[name]) and any_in_extra_tree(remote_list[name]):
				remote_list[name] = not_main(remote_list[name])
			else:
				remote_list[name] = not_main_or_extra(remote_list[name])
		try_dump(remote_list, slackroll_remotelist_filename)
	return try_load(slackroll_remotelist_filename)

def get_word_from_file(filepath):
	try:
		filename = os.path.basename(filepath)
		lines = file(filepath, 'r').readlines()
		if len(lines) != 1:
			raise ValueError('more than one line on %s file' % filename)
		mirror = lines[0].strip()
		if len(mirror) == 0:
			raise ValueError('%s is empty' % filename)
		return mirror
	except (OSError, IOError, ValueError), err:
		sys.exit('ERROR: %s' % err)

def get_mirror(): # From the 'mirror' file
	return get_word_from_file(slackroll_mirror_filename)

def get_primary_mirror():
	if is_readable_file(slackroll_primary_mirror_filename):
		return get_word_from_file(slackroll_primary_mirror_filename)
	return slackroll_default_primary_site_url

def set_mirror(mirror): # Writes the mirror name to the 'mirror' file
	try:
		file(slackroll_mirror_filename, 'w').write('%s\n' % mirror)
	except (OSError, IOError, ValueError), err:
		sys.exit('ERROR: %s' % err)

def get_version_from_mirror(mirror): # Extract Slackware version from mirror URL
	match = slackroll_mirror_version_re.search(mirror)
	if match is None:
		sys.exit('ERROR: unable to extract Slackware version from mirror name')
	return match.group(1)

def get_pkg_cache_size(): # Return total bytes for files in cache
	try:
		return sum(os.path.getsize(x) for x in glob.glob(slackroll_pkgs_dir_glob))
	except (OSError, IOError), err:
		sys.exit('ERROR: %s' % err)

def call_pager(): # Call pager and return handler
	try:
		pager = get_pager()
		pager_list = pager.split()
		proc = subprocess.Popen(pager_list, stdin=subprocess.PIPE)
		return proc
	except (OSError, IOError), err:
		sys.exit('ERROR: %s' % err)

def getwinsize(): # Returns terminal (rows, columns)
	# XXX - Weird code
	#
	# This code needs to invoke the TIOCGWINSZ ioctl and read 4 unsigned
	# short values that would be written to a struct. In C, you pass
	# the struct pointer as an argument to ioctl() and read the struct
	# members after the call, but in Python we need to pass a string
	# buffer that will be copied and modified by the underlying call,
	# and then returned. This string needs to be parsed and interpreted
	# into 4 values. The struct module eases this task. The 4 variables
	# are given the same name they have in the C winsize structure.

	bufsize = struct.calcsize('HHHH')
	bytes = fcntl.ioctl(sys.stdout.fileno(), termios.TIOCGWINSZ, '\x00' * bufsize)
	(ws_row, ws_col, ws_xpixel, ws_ypixel) = struct.unpack('HHHH', bytes)
	return (ws_row, ws_col)

def too_many_lines(numlines): # Returns True if lines do not fit in screen
	if not sys.stdout.isatty():
		return False
	(rows, cols) = getwinsize()
	return (numlines >= rows)

class SlackRollOutputInterceptor(object): # Intercepts stdout and uses a pager if the output is too long
	__was_not_tty = None
	__old_stdout = None
	__buffer = None

	def __init__(self):
		if not sys.stdout.isatty():
			self.__was_not_tty = True
			return
		self.__buffer = cStringIO.StringIO()
		self.__old_stdout = sys.stdout
		sys.stdout = self.__buffer
	
	def stop(self):
		if self.__was_not_tty:
			return
		sys.stdout = self.__old_stdout
		self.__old_stdout = None
		output = self.__buffer.getvalue()
		self.__buffer.close()
		numlines = output.count('\n')
		if too_many_lines(numlines):
			proc = call_pager()
			proc.stdin.write(output)
			proc.stdin.close()
			proc.wait()
		else:
			sys.stdout.write(output)

def run_program(arg_list): # Does not exit on errors
	try:
		subprocess.call(arg_list)
	except (OSError, IOError), err:
		sys.stderr.write('ERROR: %s\n' % err)

def run_visual_on(file_path): # Does not exit on errors
	run_program(get_visual().split() + [file_path])

def run_difftool_on(oldfile, newfile): # Does not exit on errors
	run_program(get_difftool().split() + [oldfile, newfile])

def try_to_remove(file_path, fatal=True): # When it returns, it is True if file does not exist on exit
	if not os.path.exists(file_path):
		return True
	try:
		os.remove(file_path)
		return True
	except (OSError, IOError), err:
		sys.stderr.write('ERROR: %s\n' % err)
		if fatal:
			sys.exit(slackroll_exit_failure)
		return False

def try_to_rename(src, dest, fatal=True): # When it returns, it is True if file could be renamed
	try:
		os.rename(src, dest)
		return True
	except (OSError, IOError), err:
		sys.stderr.write('ERROR: %s\n' % err)
		if fatal:
			sys.exit(slackroll_exit_failure)
		return False

def download_report_hook(filename, numblocks, blocksize, totalsize): # Template for urllib.urlretrieve() callbacks
	if totalsize == -1:
		percent = 'N/A'
		size = 'N/A'
	else:
		percent = min(int(round(numblocks * blocksize * 100.0 / totalsize)), 100)
		size = optimum_size_conversion(totalsize)
	print_flush('\rDownloading %s ... %s%% of %s' % (filename, percent, size))

def download_file(mirror, filepath, local_temp, local_final): # Does not exit on errors and shouldn't be called directly
	try:
		filename = os.path.basename(filepath)
		print_flush('Downloading %s ... ' % filename)
		full_url = urlparse.urljoin(mirror, filepath)
		hook = lambda a, b, c: download_report_hook(filename, a, b, c)
		urllib.urlretrieve(full_url, local_temp, hook)
		print
		if not try_to_rename(local_temp, local_final, fatal=False):
			raise SlackRollError('rename error: %s => %s' % (local_temp, local_final))
	except (OSError, IOError, socket.error, urllib.ContentTooShortError), err:
		sys.stderr.write('\nERROR: %s\n' % err)
		raise SlackRollError(str(err))

def download(mirror, filepath, localdir): # Wrapper that does NOT exit on errors
	name = os.path.basename(filepath)
	localtemp = os.path.join(get_temp_dir(), '%s%s' % (name, slackroll_temp_suffix))
	localfinal = os.path.join(localdir, name)
	download_file(mirror, filepath, localtemp, localfinal)

def download_or_exit(mirror, filepath, localdir): # Wrapper that exits on errors
	try:
		download(mirror, filepath, localdir)
	except SlackRollError:
		sys.exit(slackroll_exit_failure)

def handle_writable_dir(dirname): # Make sure dirname is available and writable
	if not os.path.exists(dirname):
		try:
			os.mkdir(dirname)
		except (OSError, IOError), err:
			sys.exit('ERROR: %s' % err)
	if not os.path.isdir(dirname):
		sys.exit('ERROR: %s exists but is not a directory' % dirname)
	if not os.access(dirname, os.R_OK | os.W_OK):
		sys.exit('ERROR: directory %s is not available for read and writing' % dirname)

def yield_gnupg_exec_name():
	for opt in slackroll_gnupg_exec_names:
		try:
			subprocess.call([opt, '--version'], stdout=(file(os.path.devnull, 'w')), stderr=subprocess.STDOUT)
			while True:
				yield opt
		except (OSError, IOError):
			pass
	sys.exit('ERROR: unable to run GnuPG')

def gnupg_exec_name():
	return yield_gnupg_exec_name().next()

def import_key(filename):
	try:
		print 'Importing keys from %s ...' % filename
		retcode = subprocess.call([gnupg_exec_name(), '--import', filename], stdout=file(os.path.devnull, 'w'), stderr=subprocess.STDOUT)
		if retcode != 0:
			raise SlackRollError('GnuPG exited with error when importing key')
	except (OSError, IOError, SlackRollError), err:
		sys.exit('ERROR: %s' % err)

def verify_signature(filename):	# Does not exit on errors
	try:
		print 'Verifying signature %s ... ' % os.path.basename(filename)
		retcode = subprocess.call([gnupg_exec_name(), '--verify', filename], stdout=file(os.path.devnull, 'w'), stderr=subprocess.STDOUT)
		if retcode != 0:
			sys.stderr.write('ERROR: signature verification failed: %s\n' % filename)
			raise SlackRollError('GnuPG exited with status code %s' % retcode)
	except (OSError, IOError), err:
		sys.stderr.write('ERROR: %s\n' % err)
		raise SlackRollError(str(err))

def upgrade_or_install(filename, reinstall): # upgradepkg
	try:
		print 'Installing %s ...' % os.path.basename(filename)
		retcode = subprocess.call(['/sbin/upgradepkg', '--install-new'] + ([[], ['--reinstall']][reinstall]) + [filename])
		if retcode != 0:
			sys.exit('ERROR: installation failed: %s' % filename)
	except (OSError, IOError), err:
		sys.exit('ERROR: %s' % err)

def replace_pkg(installed_filename, new_filename): # upgradepkg using '%' notation
	try:
		print 'Installing %s ...' % os.path.basename(new_filename)
		retcode = subprocess.call(['/sbin/upgradepkg', '%s%%%s' % (installed_filename, new_filename)])
		if retcode != 0:
			sys.exit('ERROR: installation failed: %s' % new_filename)
	except (OSError, IOError), err:
		sys.exit('ERROR %s' % err)

def remove_pkg(removepkg_arg): # removepkg
	try:
		print 'Removing %s ...' % removepkg_arg
		retcode = subprocess.call(['/sbin/removepkg', removepkg_arg])
		if retcode != 0:
			sys.exit('ERROR: removal failed: %s' % removepkg_arg)
	except (OSError, IOError), err:
		sys.exit('ERROR: %s' % err)

def remove_pkgs(pkg_list):
	dotnew_files = extract_dotnew_files(pkg_list)
	for pkg in pkg_list:
		remove_pkg(pkg.idname)
	handle_dotnew_files_removal(dotnew_files)

def package_in_cache(package): # Check if package is in ./packages
	filepath = os.path.join(slackroll_pkgs_dir, package.archivename)
	return is_readable_file(filepath)

def download_verify(mirror, package): # Download package, signature and verify it
	sigmirror = slackroll_primary_site_url % get_version_from_mirror(mirror)
	tempdir = get_temp_dir()
	remote_name = package.fullname
	remote_sig = '%s%s' % (remote_name, slackroll_signature_suffix)
	local_name = os.path.join(tempdir, package.archivename)
	local_sig = '%s%s' % (local_name, slackroll_signature_suffix)
	local_final = os.path.join(slackroll_pkgs_dir, package.archivename)

	try:
		download(mirror, remote_name, tempdir)
		download(sigmirror, remote_sig, tempdir)
		verify_signature(local_sig)
	except SlackRollError:
		try_to_remove(local_sig)
		try_to_remove(local_name)
		return None

	try_to_remove(local_sig)
	try_to_rename(local_name, local_final)
	return local_final

def get_remote_info(mirror, package): # Downloads info file and returns its contents
	remote_file = package.fullname[:-len(slackroll_info_suffix)] + slackroll_info_suffix
	local_file = os.path.join(slackroll_base_dir, os.path.basename(remote_file))
	download_or_exit(mirror, remote_file, slackroll_base_dir)
	data = file(local_file, 'r').read()
	try_to_remove(local_file)
	return data

def update_changelog(mirror, full=False): # Returns answer to "has it been updated?"
	if not os.path.exists(slackroll_local_changelog) or full:
		temp_dir = get_temp_dir()
		download_or_exit(mirror, slackroll_changelog_filename, temp_dir)
		local_filename = os.path.join(temp_dir, slackroll_changelog_filename)
		text = file(local_filename).read()
		cl = ChangeLog()
		cl.add_entries(clentrylist_from_text(text))
		try_dump(cl, slackroll_local_changelog)
		try_to_remove(local_filename)
		return True

	print_flush('Updating change log ... ')

	try: # Only read until last known entry
		cl = try_load(slackroll_local_changelog)
		limits = set(concat([[x.timestamp for x in cl.get_batch(y)] for y in xrange(cl.num_batches())]))
	except (OSError, IOError), err:
		sys.exit('ERROR: %s' % err)

	changelog_url = urlparse.urljoin(mirror, slackroll_changelog_filename)
	lines = []
	try:
		conn = urllib.urlopen(changelog_url)
		while True:
			new_line = conn.readline()
			if len(new_line) == 0 or new_line.strip() in limits:
				break
			lines.append(new_line)
		conn.close()
	except (OSError, IOError, socket.error, urllib.ContentTooShortError), err:
		sys.exit('\nERROR: %s' % err)

	if len(lines) == 0:
		print 'no new entries.'
		return False
	print 'new entries found.'
	cl.start_new_batch()
	cl.add_entries(clentrylist_from_text(''.join(lines)))
	try_dump(cl, slackroll_local_changelog)
	return True

def print_urls(mirror, package):
	sigmirror = slackroll_primary_site_url % get_version_from_mirror(mirror)
	pkgurl = package.url(mirror)
	sigurl = '%s%s' % (package.url(sigmirror), slackroll_signature_suffix)
	print pkgurl
	print sigurl

def choose_option(option_list): # Prompt user and return option index
	print 'Choose option:'
	for (code, text) in option_list:
		print '    (%s) %s' % (code, text)
	codes = [x[0].lower() for x in option_list]
	while True:
		print_flush('You choose option... ')
		chosen = raw_input().lower()
		if chosen not in codes:
			continue
		break
	return codes.index(chosen)

def choose_pkg(pkg_list): # Returns chosen package or None
	options = [(str(x + 1), pkg_list[x].fullname) for x in xrange(len(pkg_list))]
	chosen = choose_option(options)
	return pkg_list[chosen]

def any_in_main_tree(pkg_list): # True if any package from the list is in the main tree
	return (len([x for x in pkg_list if slackroll_main_indicator in x.path]) > 0)

def any_in_extra_tree(pkg_list): # True if any package from the list is in the extra tree
	return (len([x for x in pkg_list if slackroll_extra_indicator in x.path]) > 0)

def not_pasture(pkg_list): # Returns packages not in pasture
	return [x for x in pkg_list if slackroll_pasture_indicator not in x.path]

def not_main(pkg_list): # Returns packages not in the main tree
	return [x for x in pkg_list if slackroll_main_indicator not in x.path]

def not_main_or_extra(pkg_list): # Returns packages not in the main or extra trees
	return [x for x in pkg_list if slackroll_main_indicator not in x.path and slackroll_extra_indicator not in x.path]

def pkgs_in_state(persistent_list, state_list): # Get persistent_list names with matching state
	return [x for x in persistent_list if persistent_list[x] in state_list]

def key_pkg_in(name_list): # Does any name match with a prioritized package?
	return (len(set(slackroll_prioritized_pkgs).intersection(set(name_list))) > 0)

def key_transient_pkgs(persistent_list):
	return [x for x in slackroll_prioritized_pkgs if persistent_list[x] in slackroll_transient_states]

def key_pkg_activity_pending(persistent_list): # True if any new, outdated or unavailable package is prioritized
	return (len(key_transient_pkgs(persistent_list)) > 0)

def maybe_print_key_pkg_watchout(persistent_list):
	if key_pkg_activity_pending(persistent_list):
		print '\nWATCH OUT: ACTIVITY IN KEY SYSTEM PACKAGES\n'
		return True
	return False

def maybe_print_key_pkg_warning(persistent_list):
	if key_pkg_activity_pending(persistent_list):
		print 'WARNING: It seems there is activity in key system packages'
		print 'WARNING: You should use "upgrade-key-packages" first'
		return True
	return False

def maybe_print_new_warning(persistent_list):
	if len(pkgs_in_state(persistent_list, [slackroll_state_new])) > 0:
		print 'WARNING: There are new packages'
		return True
	return False

def maybe_print_outdated_warning(persistent_list):
	if len(pkgs_in_state(persistent_list, [slackroll_state_outdated])) > 0:
		print 'WARNING: There are outdated packages'
		return True
	return False

def maybe_print_proxies_warning():
	proxies = [x for x in os.environ if re.search(r'(?i)_proxy$', x) is not None]
	if len(proxies) == 0:
		return
	print 'WARNING: the following proxies are set: %s' % ' '.join(proxies)

def confirm_continue():
	raw_input('Press Ctrl+C to cancel or Enter to continue... ')

def print_in_states(states, persistent_list, header, print_state): # Print package name if its state matches
	keys = pkgs_in_state(persistent_list, states)
	if len(keys) == 0:
		return
	print header
	keys.sort(cmp=pkg_name_cmp)
	if print_state:
		fmt = '    %%-%ss  %%s' % max(len(slackroll_state_strings[x]) for x in slackroll_all_states)
		items = [(slackroll_state_strings[persistent_list[x]], x) for x in keys]
	else:
		fmt = '    %s'
		items = keys
	print '\n'.join(fmt % x for x in items)
	print 'End of list'

def print_in_states_or(states, persistent_list, header, message_on_empty, print_state): # Idem using interceptor and a message if no matches
	keys = pkgs_in_state(persistent_list, states)
	if len(keys) == 0:
		print message_on_empty
		return
	interceptor = SlackRollOutputInterceptor()
	print_in_states(states, persistent_list, header, print_state)
	interceptor.stop()

def print_seq(seq, header): # Print every item in sequence, sorted with pkg_name_cmp()
	if len(seq) == 0:
		return
	print header
	items = [x for x in seq]
	items.sort(cmp=pkg_name_cmp)
	for item in items:
		print '    %s' % item
	print 'End of list'

def print_seq_or(seq, header, message_on_empty): # Idem using interceptor and a message if no items
	if len(seq) == 0:
		print message_on_empty
		return
	interceptor = SlackRollOutputInterceptor()
	print_seq(seq, header)
	interceptor.stop()

def print_list(the_list, header): # Print every list entry, sorted
	if len(the_list) == 0:
		return
	print header
	the_list.sort()
	for entry in the_list:
		print '    %s' % entry
	print 'End of list'

def print_list_or(the_list, header, message_on_emtpy): # Idem using interceptor and a message if empty list
	if len(the_list) == 0:
		print message_on_emtpy
		return
	interceptor = SlackRollOutputInterceptor()
	print_list(the_list, header)
	interceptor.stop()

def tr_pkg_detail(local_list, remote_list, persistent_list, pkg_name): # Returns a string with package details for a transient package
	if persistent_list[pkg_name] != slackroll_state_new:
		return ''
	return ' '.join(x.path for x in remote_list[pkg_name])

def error_unknown_packages(name_list): # Print package names as unknown and exit with error
	sys.stderr.write(''.join('WARNING: %s looks like an unexpected full version\n' % x for x in name_list if may_be_full_version(x)))
	sys.stderr.write('ERROR: The following packages are unknown:\n')
	sys.stderr.write(''.join('ERROR:    %s\n' % x for x in name_list))
	sys.exit(slackroll_exit_failure)

def maybe_error_unknown_packages(name_list, by_name):
	unknown = [x for x in name_list if x not in by_name]
	if len(unknown) > 0:
		error_unknown_packages(unknown)

def from_states_to_state(orig_states, dest_state, persistent_list, pkg_names): # Changes state if it matches
	maybe_error_unknown_packages(pkg_names, persistent_list)
	dest_st_name = slackroll_state_strings[dest_state]
	print 'Marking packages as %s...' % dest_st_name
	for name in pkg_names:
		cur_st = persistent_list[name]
		if cur_st not in orig_states:
			print '%s: cannot change state from %s to %s' % (name, slackroll_state_strings[cur_st], dest_st_name)
			continue
		persistent_list[name] = dest_state
		persistent_list.sync()

def query_pkg_browser(version, searchstr): # Query package browser on given file with given Slackware version
	url = slackroll_pb_template_url % (urllib.quote(version), urllib.quote(searchstr))
	try:
		data = urllib.urlopen(url).read()
	except (OSError, IOError, socket.error, urllib.ContentTooShortError), err:
		sys.exit('ERROR: %s' % err)

	# Extract results from answer webpage
	data = re.sub(r'(?s)<!--.*?-->', '', data) # Strip HTML comments
	has_results = False
	header_printed = False
	
	for match in re.finditer(slackroll_pb_result_re, data):
		has_results = True
		if not header_printed:
			print 'Results for %s:' % searchstr
			header_printed = True
		pkgstr = match.group(slackroll_pb_result_idname)
		pkgcontents = match.group(slackroll_pb_result_files)

		print '    %s%s' % (re.sub(r'\s', '', pkgstr), slackroll_pkg_archive_suffix)
		print ''.join('\t%s\n' % x for x in re.split(r'(?i)<br[^>]*>', re.sub(r'(?i)(\s)|(</?b>)', '', pkgcontents)))
	
	if not has_results:
		print 'Results for %s:' % searchstr
		print '    (No results)\n'

def extract_dotnew_files(local_pkg_list): # Get .new files from multiple packages
	full = concat([[x for x in extract_file_list(pkg.fullname) if x.endswith(slackroll_new_suffix)] for pkg in local_pkg_list])
	return sorted(set(full))

def old_file(filename): # Returns filename without .new suffix
	if filename.endswith(slackroll_new_suffix):
		return filename[:-(len(slackroll_new_suffix))]
	return filename

def handle_dotnew_files_installation(dotnew_files): # Handles .new files present in packages
	if len(dotnew_files) == 0:
		return

	visual = get_visual()
	srdiff = get_difftool()
	existence_text = ['MISSING', 'FOUND  ']

	# Iterate over every pair of .new files
	for newfile in dotnew_files:
		oldfile = old_file(newfile)
		basenew = os.path.basename(newfile)
		baseold = os.path.basename(oldfile)

		# Every possible menu option
		go_next = ('X', 'Review next pair')
		remove_new = ('R', 'rm %s' % basenew)
		rename_new = ('M', 'mv %s %s' % (basenew, baseold))
		run_difftool = ('V', '%s %s %s' % (srdiff, baseold, basenew))
		visual_new = ('V', '%s %s' % (visual, basenew))
		visual_old = ('V', '%s %s' % (visual, baseold))

		# Repeating options menu (break when user chooses to review next file)
		pair_iterations = 0
		while True:
			pair_iterations += 1
			try:
				new_exists = os.path.exists(newfile)
				old_exists = os.path.exists(oldfile)
			except (OSError, IOError), err:
				sys.stderr.write('ERROR: %s\n' % err)
				break

			print '\n%s %s' % (['Reviewing', 'Still reviewing'][pair_iterations > 1], newfile)
			print '    %s  %s' % (existence_text[old_exists], baseold)
			print '    %s  %s' % (existence_text[new_exists], basenew)

			# Different options depending on which files exist
			if new_exists and old_exists: # Both
				options = [go_next, remove_new, rename_new, run_difftool]
				chosen = choose_option(options)
				if chosen == 0:
					break
				elif chosen == 1:
					print 'Removing %s ...' % newfile
					try_to_remove(newfile, fatal=False)
				elif chosen == 2:
					print 'Renaming %s ...' % newfile
					try_to_rename(newfile, oldfile, fatal=False)
				else:
					run_difftool_on(oldfile, newfile)

			elif new_exists and not old_exists: # New only
				options = [go_next, rename_new, visual_new]
				chosen = choose_option(options)
				if chosen == 0:
					break
				if chosen == 1:
					print 'Renaming %s ...' % newfile
					try_to_rename(newfile, oldfile, fatal=False)
				else:
					run_visual_on(newfile)

			elif not new_exists and old_exists: # Old only
				options = [go_next, visual_old]
				chosen = choose_option(options)
				if chosen == 0:
					break
				else:
					run_visual_on(oldfile)
			else: # None
				options = [go_next]
				chosen = choose_option(options)
				break

def handle_dotnew_files_removal(dotnew_files): # Prompt the user about .new files left behind by removepkg
	if len(dotnew_files) == 0:
		return

	pairs = [[x, old_file(x)] for x in dotnew_files]
	to_be_checked = concat(pairs)

	for path in to_be_checked:
		if not os.path.islink(path) and not os.path.exists(path):
			continue # Does not exist in any form
		print '\nFound %s' % path
		options = [ ('K', 'Keep it'), ('R', 'Remove it') ]
		chosen = choose_option(options)
		if chosen == 1:
			try_to_remove(path, fatal=False)

def handle_dotnew_files_both(prev_dotnew, cur_dotnew): # Handle installation and removal of pairs left behind
	handle_dotnew_files_installation(cur_dotnew)
	handle_dotnew_files_removal(list(frozenset(prev_dotnew) - frozenset(cur_dotnew)))

def may_be_full_version(pkg_string):
	try:
		pkg_from_str(pkg_string)
		return True
	except SlackRollError:
		pass
	return False

def verify_local_names(names, local_list):
	for name in names:
		if name not in local_list:
			if may_be_full_version(name):
				print 'WARNING: %s looks like an unexpected full version' % name
			sys.exit('ERROR: %s is not a local package name' % name)

def parse_pkg_arg(arg): # Returns tuple (Is full name?, Name, SlackwarePackage or None) -- auxiliar of parse_install_args()
	if arg.endswith(slackroll_pkg_archive_suffix) or os.path.sep in arg:
		try:
			pkg = pkg_from_str(arg)
			name = pkg.name
			return (True, name, pkg)
		except SlackRollError:
			sys.exit('ERROR: unable to parse specific package version: %s' % arg)
	return (False, arg, None)

def parse_install_args(args, local_list, remote_list, use_local_version, use_pasture): # Return chosen_pkgs -- auxiliar of install_operations_family()
	chosen_pkgs = []
	for arg in args:
		# Decide the type of argument (full name or simple name)
		(is_full, name, pkg) = parse_pkg_arg(arg)

		if is_full:
			# Specific version given
			if use_local_version and pkg_in_map(pkg, local_list):
				chosen_pkgs.append([x for x in local_list[name] if x == pkg][0])
			else:
				try:
					chosen_pkgs.append(remote_list[name][remote_list[name].index(pkg)])
				except (KeyError, ValueError):
					sys.exit('ERROR: unable to find remote package %s' % pkg.archivename)
			continue

		# Only generic name given
		if name not in remote_list and ((not use_local_version) or (use_local_version and name not in local_list)):
			if may_be_full_version(name):
				print 'WARNING: %s suffix may be missing on %s' % (slackroll_pkg_archive_suffix, name)
			sys.exit('ERROR: no package named %s' % name)

		# Create candidate list
		candidates = []
		if use_local_version:
			candidates.extend(local_list.get(name, []))
		candidates.extend(x for x in remote_list.get(name, []) if x not in candidates)

		if not use_pasture: # Filter /pasture/ candidates if indicated
			candidates = not_pasture(candidates)

		# Choose among the candidates
		if len(candidates) == 0:
			print 'WARNING: %s only present in /pasture/' % name
		elif len(candidates) == 1:
			chosen_pkgs.append(candidates[0])
		else:
			if not use_local_version:
				for pkg in local_list.get(name, []):
					print 'Local: %s' % pkg.archivename
			chosen = choose_pkg(candidates)
			if chosen is not None:
				chosen_pkgs.append(chosen)
	return chosen_pkgs

def install_operations_family(operation, args, local_list, remote_list, persistent_list, use_pasture=True):
	is_real_install = (operation in ['install', 'reinstall'])
	use_local_version = (operation == 'info')

	# Warn the user on install and reinstall operations if there is key package activity and they have not indicated key packages
	if is_real_install and not key_pkg_in(args) and maybe_print_key_pkg_warning(persistent_list):
		confirm_continue()

	# Get mirror and parse arguments (package names or full versions)
	mirror = get_mirror()
	chosen_pkgs = parse_install_args(args, local_list, remote_list, use_local_version, use_pasture)

	# For install and reinstall operations save list of existing .new file pairs
	if is_real_install:
		prev_dotnew = extract_dotnew_files(concat([local_list[pkg.name] for pkg in chosen_pkgs if pkg.name in local_list]))

	# After selecting the packages, run the requested operation on them
	if operation in ['install', 'reinstall', 'download', 'urls']:
		print 'Total size: %s' % optimum_size_conversion(sum(x.size for x in chosen_pkgs))
		if operation in ['install', 'reinstall', 'download']:
			to_be_downloaded = [x for x in chosen_pkgs if not package_in_cache(x)]
			cached_ones = [x for x in chosen_pkgs if x not in to_be_downloaded]

			for pkg in cached_ones:
				print 'Package %s found in cache' % pkg.archivename

			if not enough_fs_resources(len(to_be_downloaded), sum(x.size for x in to_be_downloaded)):
				low_fs_resources_warning()
				confirm_continue()

			local_pkgs = [os.path.join(slackroll_pkgs_dir, x.archivename) for x in cached_ones]
			for pkg in to_be_downloaded:
				local_name = download_verify(mirror, pkg)
				if local_name is None:
					sys.exit(slackroll_exit_failure)
				local_pkgs.append(local_name)
			if is_real_install:
				reinstall = (operation == 'reinstall')
				for pkg in local_pkgs:
					upgrade_or_install(pkg, reinstall)
		else:	# urls operation
			for pkg in chosen_pkgs:
				print_urls(mirror, pkg)

	else:	# info operation
		info_map = dict()
		for pkg in chosen_pkgs:
			try:
				if pkg_in_map(pkg, local_list):
					lines = file(pkg.fullname, 'r').readlines()
					header = lines[:lines.index(slackroll_local_pkg_filelist_marker)]
					info_map[pkg.fullname] = ''.join(header)
				else:
					info_map[pkg.fullname] = get_remote_info(mirror, pkg)
			except (OSError, IOError), err:
				sys.exit('ERROR: %s' % err)
		interceptor = SlackRollOutputInterceptor()
		for pkg in chosen_pkgs:
			print info_map[pkg.fullname]
		interceptor.stop()
	
	# Review installed .new files
	if is_real_install:
		cur_dotnew = extract_dotnew_files([x.local() for x in chosen_pkgs])
		handle_dotnew_files_both(prev_dotnew, cur_dotnew)

def walk_append_if(root, condition, output): # Walk with os.walk() and append if entries make condition true
	abspath = os.path.abspath(root)
	for (dirpath, dirnames, filenames) in os.walk(abspath):
		for sub in dirnames + filenames:
			full = os.path.join(dirpath, sub)
			if condition(full):
				output.append(full)

def is_not_link(path):
	return not os.path.islink(path)

def is_broken_link(path):
	return os.path.islink(path) and not os.path.exists(path)

def up_to_date(local_versions, remote_versions): # Is the local package up to date?
	return (len([x for x in local_versions if x in remote_versions]) > 0)

def outdated_or_installed(local_versions, remote_versions): # Returns outdated or installed state depending on up_to_date()
	return [slackroll_state_outdated, slackroll_state_installed][up_to_date(local_versions, remote_versions)]

def analyze_changes(local_list, remote_list, persistent_list): # XXX THIS FUNCTION IS A CENTRAL PIECE OF CODE
	print 'Updating persistent database...'
	already_analyzed = set()

	# Go over packages present in local system and update their state or introduce them
	for name in local_list:
		already_analyzed.add(name)
		if name in persistent_list:
			# Update their state if needed
			state = persistent_list[name]
			if state in [slackroll_state_new, slackroll_state_notinstalled]:
				if name in remote_list:
					persistent_list[name] = outdated_or_installed(local_list[name], not_pasture(remote_list[name]))
				else:
					persistent_list[name] = slackroll_state_unavailable
			elif state in [slackroll_state_unavailable, slackroll_state_foreign]:
				if name in remote_list:
					persistent_list[name] = outdated_or_installed(local_list[name], not_pasture(remote_list[name]))
			elif state in [slackroll_state_frozen]:
				if name not in remote_list:
					persistent_list[name] = slackroll_state_unavailable
			elif state in [slackroll_state_installed, slackroll_state_outdated]:
				if name not in remote_list:
					persistent_list[name] = slackroll_state_unavailable
				else:
					persistent_list[name] = outdated_or_installed(local_list[name], not_pasture(remote_list[name]))
				
		else:
			# Introduce them in the persistent list
			if name in remote_list:
				persistent_list[name] = outdated_or_installed(local_list[name], not_pasture(remote_list[name]))
			else:
				persistent_list[name] = slackroll_state_unavailable
		persistent_list.sync()
	
	# Go over remaining remote packages not already analyzed (hence, not present in local system)
	for name in remote_list:
		if name in already_analyzed:
			continue
		already_analyzed.add(name)
		if name in persistent_list:
			# Update their state if needed
			state = persistent_list[name]
			if state in [slackroll_state_unavailable]:
				persistent_list[name] = slackroll_state_new
			elif state in [slackroll_state_installed, slackroll_state_outdated, slackroll_state_foreign, slackroll_state_frozen]:
				persistent_list[name] = slackroll_state_notinstalled
		else:
			# Introduce them as new unless they are only present in /pasture/
			if len(not_pasture(remote_list[name])) == 0:
				persistent_list[name] = slackroll_state_notinstalled
			else:
				persistent_list[name] = slackroll_state_new
		persistent_list.sync()
	
	# Remaining packages, not present in local or remote systems, need to disappear
	for name in persistent_list.keys():	# Must get keys before, as we are going to delete entries
		if name in already_analyzed:
			continue
		del persistent_list[name]
		persistent_list.sync()

def print_help():
	interceptor = SlackRollOutputInterceptor()
	print """Available operations:

help			Print this help
version			Print the program version
set-mirror URL		Sets the mirror URL
print-mirror		Prints the mirror URL
update			Download remote tree information
import-key		Download and import the GPG key
changelog		Displays the last downloaded ChangeLog.txt batch
download-changelog	Download the full ChangeLog.txt
list-changelog		List all known changelog entries and their identifiers
changelog-entries ID...	Display changelog entries by identifier
full-changelog		Display every known changelog entry
upgrade			Upgrade system packages
upgrade-key-packages	Upgrade key system packages
download-upgrades	Like 'upgrade' but without installing
download-key-packages	Like 'upgrade-key-packages' but without installing
urls-upgrades		Like 'upgrade' but only printing URLs
urls-key-packages	Like 'upgrade-key-packages' but only printing URLs
clean-cache		Remove unknown package versions from package cache
erase-cache		Remove every file from package cache
erase-tmp		Remove every file from the temporary directory
erase-all		Remove every file from both locations above
touch			Force update on persistent database
list-transient		Combined list of new, unavailable and outdated packages
list-upgrades		List available upgrades
list-outdated-frozen	List frozen packages that would be outdated otherwise
list-alternatives	List packages with alternative versions
list-versions PKG...	List all known versions of given packages
state PKG...		Show state of given packages
list-new		List new packages
list-unavailable	List unavailable packages
list-installed		List installed packages
list-not-installed	List not installed packages
list-frozen		List frozen packages
list-foreign		List foreign packages
list-outdated		List outdated packages
list-local		List all local packages (present in system)
list-remote		List all remote packages (present in remote tree)
list-all		List every known package
new-not-installed	Mark all new packages as not installed
unavailable-foreign	Mark all unavailable packages as foreign
new PKG...		Mark packages as new
unavailable PKG...	Mark packages as unavailable
installed PKG...	Mark packages as installed
not-installed PKG...	Mark packages as not installed
foreign PKG...		Mark packages as foreign
frozen PKG...		Mark packages as frozen
freeze PKG...		Alias for 'frozen'
install PKG...		Install packages or specific package versions
install-new		Install all new packages
install-path REGEX...	Install all packages with matching path
install-foreign PATH...	Install a foreign package from disk
reinstall PKG...	Same as 'install' but reinstalls if needed
replace UNAV NEW	Replace an unavailable package with a new one
download PKG...		Download packages or specific package versions
download-new		Download all new packages
download-path REGEX...	Download all packages with matching path
info PKG...		Show info about packages or specific package versions
info-new		Show info about all new packages
info-path REGEX...	Show info about all packages with matching path
local-info PKG...	Show full package information from /var/log/packages
urls PKG...		Show package or specific package version URLs
urls-new		Show URLs for all new packages
urls-path REGEX...	Show URLs for all packages with matching path
remove PKG...		Remove packages
remove-unavailable	Remove every unavailable package
remove-path REGEX...	Remove all packages with matching path
remote-paths		Print a plain list of the remote package paths
print-blacklist		Print all the expressions in the blacklist
blacklist-add REGEX...	Add an expression to the blacklist
blacklist-del INDEX...	Delete an expression from the blacklist
pb-search FILE...	Search for files in the Slackware Package Browser
remote-search FILE...	Alias for 'pb-search'
local-search REGEX...	Search for files in local packages
name-search REGEX...	Search for package names matching regular expressions
path-search REGEX...	Search for remote packages having matching path
orphan-search PATH...	Search for orphan files in local system
broken-symlinks PATH...	Search for broken symlinks in local system
missing-search		Search for missing files in local system

Visit http://slackroll.sourceforge.net/ for a tutorial and more help.
"""
	interceptor.stop()

def verify_num_args(opname, num, arg_list): # Verify number of arguments of a given operation (-1 means any nonzero quantity)
	if num == -1:
		if len(arg_list) == 0:
			sys.exit('ERROR: %s expects more arguments' % opname)
	else:
		if len(arg_list) != num:
			sys.exit('ERROR: %s expects %s argument%s' % (opname, ['no', str(num)][num > 0], ['s', ''][num == 1]))

### Main program ###
try:
	local_list = None
	remote_list = None
	persistent_list = None
	urllib._urlopener = SlackRollURLopener()
	socket.setdefaulttimeout(slackroll_socket_timeout)
	standarize_locales()

	op_num_args = {	# Map of operations and their number of arguments (-1 means any nonzero quantity)
		'blacklist-add':	-1,
		'blacklist-del':	-1,
		'broken-symlinks':	-1,
		'changelog':		0,
		'changelog-entries':	-1,
		'clean-cache':		0,
		'download':		-1,
		'download-changelog':	0,
		'download-key-packages':0,
		'download-new':		0,
		'download-path':	-1,
		'download-upgrades':	0,
		'erase-cache':		0,
		'erase-tmp':		0,
		'erase-all':		0,
		'foreign':		-1,
		'frozen':		-1,
		'freeze':		-1,
		'full-changelog':	0,
		'help':			0,
		'import-key':		0,
		'info':			-1,
		'info-new':		0,
		'info-path':		-1,
		'install':		-1,
		'install-foreign':	-1,
		'install-new':		0,
		'install-path':		-1,
		'installed':		-1,
		'list-all':		0,
		'list-alternatives':	0,
		'list-changelog':	0,
		'list-foreign':		0,
		'list-frozen':		0,
		'list-installed':	0,
		'list-local':		0,
		'list-new':		0,
		'list-not-installed':	0,
		'list-outdated':	0,
		'list-outdated-frozen':	0,
		'list-remote':		0,
		'list-transient':	0,
		'list-unavailable':	0,
		'list-upgrades':	0,
		'list-versions':	-1,
		'local-info':		-1,
		'local-search':		-1,
		'missing-search':	0,
		'name-search':		-1,
		'new':			-1,
		'new-not-installed':	0,
		'not-installed':	-1,
		'orphan-search':	-1,
		'path-search':		-1,
		'pb-search':		-1,
		'print-blacklist':	0,
		'print-mirror':		0,
		'reinstall':		-1,
		'remote-paths':		0,
		'remote-search':	-1,
		'remove':		-1,
		'remove-path':		-1,
		'remove-unavailable':	0,
		'replace':		2,
		'set-mirror':		1,
		'state':		-1,
		'touch':		0,
		'unavailable':		-1,
		'unavailable-foreign':	0,
		'update':		0,
		'upgrade':		0,
		'upgrade-key-packages':	0,
		'urls':			-1,
		'urls-key-packages':	0,
		'urls-new':		0,
		'urls-path':		-1,
		'urls-upgrades':	0,
		'version':		0,
	}

	operation = sys.argv[1]
	args = sys.argv[2:]

	# Verify number of arguments
	try:
		verify_num_args(operation, op_num_args[operation], args)
	except KeyError:
		sys.stderr.write('ERROR: unknown operation: %s\n' % operation)
		sys.stderr.write('Use "help" operation to get a list\n')
		sys.exit(slackroll_exit_failure)

	if operation == 'help':
		print_help()
		sys.exit()
	
	if operation == 'version':
		print 'SlackRoll v%s' % slackroll_version
		sys.exit()
	
	if operation == 'print-blacklist':
		print_blacklist()
		sys.exit()
	
	if operation == 'blacklist-add':
		add_blacklist_exprs(args)
		sys.exit()
	
	if operation == 'blacklist-del':
		del_blacklist_exprs(args)
		sys.exit()

	if operation == 'print-mirror':
		print get_mirror()
		sys.exit()
	
	if operation == 'set-mirror':
		set_mirror(args[0])
		sys.exit()

	if operation in ['erase-cache', 'erase-tmp', 'erase-all']:
		directories = []
		if operation in ['erase-cache', 'erase-all']:
			directories.append(slackroll_pkgs_dir)
		if operation in ['erase-tmp', 'erase-all']:
			directories.append(get_temp_dir())
		files = concat([glob.glob(os.path.join(directory, '*')) for directory in directories])
		if len(files) == 0:
			print 'No files to remove'
		else:
			files.sort()
			for filename in files:
				try_to_remove(filename)
		sys.exit()

	if operation == 'changelog':
		interceptor = SlackRollOutputInterceptor()
		cl = try_load(slackroll_local_changelog)
		print slackroll_changelog_entry_separator.join('%s' % entry for entry in cl.last_batch())
		interceptor.stop()
		sys.exit()
	
	if operation == 'list-changelog':
		interceptor = SlackRollOutputInterceptor()
		cl = try_load(slackroll_local_changelog)
		print 'ChangeLog.txt entries:'
		for idb in xrange(cl.num_batches() - 1, -1, -1):
			batch = cl.get_batch(idb)
			for ide in xrange(len(batch)):
				print '    %-8s  %s' % ('%s.%s' % (idb, ide), batch[ide].timestamp)
		print 'End of list'
		interceptor.stop()
		sys.exit()
	
	if operation == 'changelog-entries':
		cl = try_load(slackroll_local_changelog)
		entries = []
		for code in args:
			try:
				(idb, ide) = code.split('.')
				(idb, ide) = (long(idb), long(ide))
				entries.append(cl.get_batch(idb)[ide])
			except (IndexError, ValueError):
				sys.exit('ERROR: invalid entry: %s' % code)
		interceptor = SlackRollOutputInterceptor()
		print slackroll_changelog_entry_separator.join('%s' % x for x in entries)
		interceptor.stop()
		sys.exit()
	
	if operation == 'full-changelog':
		cl = try_load(slackroll_local_changelog)
		entries = concat([[x for x in cl.get_batch(y)] for y in xrange(cl.num_batches() - 1, -1, -1)])
		interceptor = SlackRollOutputInterceptor()
		print slackroll_changelog_entry_separator.join('%s' % x for x in entries)
		interceptor.stop()
		sys.exit()

	if operation in ['pb-search', 'remote-search']:
		slackver = get_version_from_mirror(get_mirror())
		print 'Using the Slackware Package Browser at %s' % slackroll_pb_location
		term = sys.stdout
		interceptor = SlackRollOutputInterceptor()
		for name in args:
			searchstr = '"%s"' % name
			print >>term, "Searching for %s..." % searchstr
			query_pkg_browser(slackver, searchstr)
		interceptor.stop()
		sys.exit()

	if operation in ['local-search', 'missing-search']:
		if operation == 'local-search':
			all_regexes = '|'.join('(%s)' % x for x in args)
			try:
				regexp = re.compile(all_regexes)
			except re.error:
				sys.exit('ERROR: invalid regular expression')
			test = lambda x: regexp.search(x) is not None
			header = 'Matching files:'
			empty = 'No matching files found'
		else: # missing-search
			long_time_warning()
			interpret_results_warning()
			confirm_continue()
			print
			test = lambda x: slackroll_never_missing_re.search(x) is None and not os.path.exists(x) and not os.path.exists(old_file(x))
			header = 'Missing files:'
			empty = 'No missing files'


		print 'Reading contents of %s ...' % slackroll_local_pkgs_dir
		pkg_files_map = get_pkg_filelists()

		matches = [(x, [y for y in pkg_files_map[x] if test(y)]) for x in sorted(pkg_files_map.keys())]
		matches = [(name, files) for (name, files) in matches if len(files) > 0]
		if len(matches) == 0:
			print empty
			sys.exit()

		matches.sort()
		interceptor = SlackRollOutputInterceptor()
		print header
		for (name, files) in matches:
			print '    %s%s' % (os.path.basename(name), slackroll_pkg_archive_suffix)
			print ''.join('\t%s\n' % x for x in files)
		print 'End of list'
		interceptor.stop()
		sys.exit()
	
	if operation == 'orphan-search':
		long_time_warning()
		interpret_results_warning()
		confirm_continue()

		print '\nReading normalized contents of %s ...' % slackroll_local_pkgs_dir
		known_files = get_normalized_known_files()

		print 'Examining specified paths...'
		tree = []
		for path in args: # Iterate over specified paths
			walk_append_if(path, is_not_link, tree)

		# Detect orphans
		print 'Finding orphan files...'
		orphans = []
		for name in tree:
			alternative = '%s%s' % (name, slackroll_new_suffix)
			if name not in known_files and alternative not in known_files:
				orphans.append(name)

		# Print results
		print_list_or(orphans, 'Orphan files:', 'No orphan files found')
		sys.exit()
	
	if operation == 'broken-symlinks':
		interpret_results_warning()
		confirm_continue()

		print '\nExamining specified paths...'
		broken_symlinks = []
		for path in args:
			walk_append_if(path, is_broken_link, broken_symlinks)

		print_list_or(broken_symlinks, 'Broken symlinks:', 'No broken symlinks found')
		sys.exit()

	# Some operations below need to have the temporary directory available to download stuff
	handle_writable_dir(get_temp_dir())

	if operation == 'update':
		maybe_print_proxies_warning()
		mirror = get_mirror()
		print 'Package cache size: %s' % optimum_size_conversion(get_pkg_cache_size())
		updated = update_changelog(mirror)
		download_or_exit(mirror, slackroll_filelist_filename, slackroll_base_dir)
		if updated:
			print 'You should now use the "changelog" operation'
		sys.exit()

	if operation == 'import-key':
		download_or_exit(slackroll_primary_site_url % get_version_from_mirror(get_mirror()), slackroll_gpgkey_filename, slackroll_base_dir)
		import_key(slackroll_local_gpgkey)
		try_to_remove(slackroll_local_gpgkey)
		sys.exit()

	if operation == 'download-changelog':
		update_changelog(get_mirror(), full=True)
		sys.exit()

	# Every operation below needs an updated persistent database
	handle_writable_dir(slackroll_pkgs_dir)
	#print 'Initializing package lists...'

	needs_forced_rebuild = (not os.path.exists(slackroll_self_filename) or get_self_file_version() != slackroll_version)
	local_list = get_local_list(needs_forced_rebuild)
	remote_list = get_remote_list(needs_forced_rebuild)

	needs_update = (newer_than(slackroll_remotelist_filename, slackroll_persistentlist_filename)
			or newer_than(slackroll_locallist_filename, slackroll_persistentlist_filename)
			or operation == 'touch' or needs_forced_rebuild)

	try:
		persistent_list = shelve.open(slackroll_persistentlist_filename, 'c')
	except anydbm.error:
		sys.exit('ERROR: unable to properly open %s' % slackroll_persistentlist_filename)

	if needs_update:
		analyze_changes(local_list, remote_list, persistent_list)
		os.utime(slackroll_persistentlist_filename, None)

	write_self_file_version()

	if operation == 'touch':
		sys.exit()
	
	if operation == 'remote-paths':
		every_remote_path = concat([[y.fullname for y in remote_list[x]] for x in remote_list])
		every_remote_path.sort()
		interceptor = SlackRollOutputInterceptor()
		for path in every_remote_path:
			print path
		interceptor.stop()
		sys.exit()

	if operation == 'state':
		maybe_error_unknown_packages(args, persistent_list)
		plist_subset = dict([(x, persistent_list[x]) for x in args])
		print_in_states_or(slackroll_all_states, plist_subset, 'Package states:', 'INTERNAL ERROR: no packages specified', True)
		sys.exit()

	if operation in ['upgrade', 'download-upgrades', 'urls-upgrades']:
		if operation == 'upgrade' and maybe_print_new_warning(persistent_list):
			confirm_continue()

		names = pkgs_in_state(persistent_list, [slackroll_state_outdated])
		names.sort(cmp=pkg_name_cmp)

		if len(names) == 0:
			print 'No outdated packages'
			sys.exit()

		opmap = { 'upgrade': 'install', 'download-upgrades': 'download', 'urls-upgrades': 'urls' }
		install_operations_family(opmap[operation], names, local_list, remote_list, persistent_list, use_pasture=False)
		sys.exit()
	
	if operation in ['upgrade-key-packages', 'download-key-packages', 'urls-key-packages']:
		names = [x for x in slackroll_prioritized_pkgs if persistent_list[x] == slackroll_state_outdated]
		if len(names) == 0:
			print 'No outdated key system packages'
			sys.exit()
		opmap = { 'upgrade-key-packages': 'install', 'download-key-packages': 'download', 'urls-key-packages': 'urls' }
		install_operations_family(opmap[operation], names, local_list, remote_list, persistent_list, use_pasture=False)
		sys.exit()

	if operation == 'clean-cache':
		cache_files = glob.glob(slackroll_pkgs_dir_glob)
		cache_pkgs = []
		extraneous_files = []

		cache_files.sort()
		for elem in cache_files:
			try:
				cache_pkgs.append(pkg_from_str(elem))
			except SlackRollError:
				extraneous_files.append(elem)

		to_be_removed = [pkg for pkg in cache_pkgs if not pkg_in_map(pkg, local_list) and not pkg_in_map(pkg, remote_list)]
		if len(to_be_removed) == 0:
			print 'No package files to remove'
		else:
			for pkg in to_be_removed:
				print 'Removing %s ...' % pkg.fullname
				try_to_remove(pkg.fullname)

		if len(extraneous_files) > 0:
			extraneous_files.sort()
			print '\n'.join('WARNING: extraneous file %s' % x for x in extraneous_files)
		sys.exit()
	
	if operation in ['list-upgrades', 'list-outdated-frozen']:
		if operation == 'list-upgrades':
			names = pkgs_in_state(persistent_list, [slackroll_state_outdated])
		else: # list-outdated-frozen
			names = pkgs_in_state(persistent_list, [slackroll_state_frozen])
			names = [x for x in names if not up_to_date(local_list[x], not_pasture(remote_list[x]))]

		if len(names) == 0:
			if operation == 'list-upgrades':
				print 'No outdated packages'
			else: # list-outdated-frozen
				print 'No frozen packages would be outdated'
			sys.exit()

		interceptor = SlackRollOutputInterceptor()
		if operation == 'list-upgrades':
			print 'Available upgrades:'
		else: # list-outdated-frozen
			print 'Would be outdated:'

		names.sort(cmp=pkg_name_cmp)
		for name in names:
			candidates = not_pasture(remote_list[name])
			if len(candidates) == 0:
				print '    %s: WARNING: only present in /pasture/\n' % name
				continue
			print '    %s:' % name
			print '\n'.join('\tLocal:\t%s' % pkg.archivename for pkg in local_list[name])
			print '\n'.join('\tRemote:\t%s' % pkg.fullname for pkg in candidates)
			print
		print 'End of list'

		if operation == 'list-upgrades':
			maybe_print_key_pkg_watchout(persistent_list)
		interceptor.stop()
		sys.exit()

	if operation == 'list-transient':
		pkgs_and_states = [(pkg, persistent_list[pkg]) for pkg in persistent_list if persistent_list[pkg] in slackroll_transient_states]
		if len(pkgs_and_states) == 0:
			print 'No transient packages found'
			sys.exit()
		pkgs_and_states.sort(cmp=transient_cmp)

		# Translate states to strings and precalculate constants
		pkgs_and_states = [(name, slackroll_state_strings[state]) for (name, state) in pkgs_and_states]
		max_state_len = max(len(slackroll_state_strings[x]) for x in slackroll_transient_states)
		max_name_len = max(len(a) for (a, b) in pkgs_and_states)
		format = '    %%-%ss  %%-%ss  %%s' % (max_state_len, max_name_len)

		# Print the transient list
		interceptor = SlackRollOutputInterceptor()
		print 'Transient packages:'
		print '\n'.join(format % (state, name, tr_pkg_detail(local_list, remote_list, persistent_list, name)) for (name, state) in pkgs_and_states)
		print 'End of list'
		maybe_print_key_pkg_watchout(persistent_list)
		interceptor.stop()
		sys.exit()

	if operation == 'list-new':
		# Very similar to list-transient
		new_pkgs = pkgs_in_state(persistent_list, [slackroll_state_new])
		if len(new_pkgs) > 0:
			max_name_len = max(len(x) for x in new_pkgs)
		else:
			max_name_len = 0
		format = '%%-%ss  %%s' % max_name_len
		pkg_and_details = [format % (x, tr_pkg_detail(local_list, remote_list, persistent_list, x)) for x in new_pkgs]
		print_seq_or(pkg_and_details, 'New packages:', 'No new packages found')
		sys.exit()
	
	if operation == 'list-alternatives':
		alternatives = dict()
		for name in persistent_list:
			versions = []
			versions.extend(remote_list.get(name, []))
			versions.extend(x for x in local_list.get(name, []) if x not in versions)
			if len(versions) > 1:
				alternatives[name] = versions

		if len(alternatives) == 0:
			print 'No packages with alternative versions'
			sys.exit()

		names = alternatives.keys()
		names.sort(cmp=pkg_name_cmp)
		interceptor = SlackRollOutputInterceptor()
		print 'Packages with alternatives:'
		for name in names:
			print '    %s:' % name
			for ver in alternatives[name]:
				print '\t%s' % ver.fullname
			print
		print 'End of list'
		interceptor.stop()
		sys.exit()

	if operation in ['list-outdated', 'list-unavailable', 'list-installed', 'list-not-installed', 'list-frozen', 'list-foreign']:
		state_str = operation.replace('list-', '')
		header = '%s packages:' % state_str.capitalize()
		empty_message = 'No %s packages found' % state_str
		state = slackroll_state_strings.index(state_str)

		interceptor = SlackRollOutputInterceptor()
		print_in_states_or([state], persistent_list, header, empty_message, False)
		if state in slackroll_transient_states:
			maybe_print_key_pkg_watchout(persistent_list)
		interceptor.stop()
		sys.exit()

	if operation == 'list-local':
		print_seq_or(local_list, 'Local packages:', 'No local packages found')
		sys.exit()

	if operation == 'list-remote':
		print_seq_or(remote_list, 'Remote packages:', 'No remote packages found')
		sys.exit()

	if operation == 'list-all':
		print_seq_or(persistent_list, 'All packages:', 'No packages found')
		sys.exit()

	if operation == 'new-not-installed':
		new_packages = pkgs_in_state(persistent_list, [slackroll_state_new])
		from_states_to_state([slackroll_state_new], slackroll_state_notinstalled, persistent_list, new_packages)
		sys.exit()

	if operation == 'unavailable-foreign':
		unavailable_packages = pkgs_in_state(persistent_list, [slackroll_state_unavailable])
		from_states_to_state([slackroll_state_unavailable], slackroll_state_foreign, persistent_list, unavailable_packages)
		sys.exit()

	if operation in ['frozen', 'freeze']:
		valid_origins = [slackroll_state_frozen, slackroll_state_installed, slackroll_state_outdated]
		from_states_to_state(valid_origins, slackroll_state_frozen, persistent_list, args)
		sys.exit()

	if operation == 'foreign':
		from_states_to_state([slackroll_state_foreign, slackroll_state_unavailable], slackroll_state_foreign, persistent_list, args)
		sys.exit()
	
	if operation == 'not-installed':
		from_states_to_state([slackroll_state_notinstalled, slackroll_state_new], slackroll_state_notinstalled, persistent_list, args)
		sys.exit()

	if operation == 'unavailable':
		from_states_to_state([slackroll_state_unavailable, slackroll_state_foreign], slackroll_state_unavailable, persistent_list, args)
		sys.exit()

	if operation == 'new':
		from_states_to_state([slackroll_state_new, slackroll_state_notinstalled], slackroll_state_new, persistent_list, args)
		sys.exit()

	if operation == 'installed':
		from_states_to_state([slackroll_state_installed, slackroll_state_frozen], slackroll_state_installed, persistent_list, args)
		analyze_changes(local_list, remote_list, persistent_list) # Forced because it may need to be marked as outdated
		os.utime(slackroll_persistentlist_filename, None)
		sys.exit()

	if operation == 'list-versions':
		maybe_error_unknown_packages(args, persistent_list)
		interceptor = SlackRollOutputInterceptor()
		print 'Available versions:'
		for name in args:
			print '    %s:' % name
			if name in local_list:
				print '\n'.join('\tLocal:\t%s' % ver.archivename for ver in local_list[name])
			if name in remote_list:
				print '\n'.join('\tRemote:\t%s' % ver.fullname for ver in remote_list[name])
			print
		print 'End of list'
		interceptor.stop()
		sys.exit()

	if operation in ['install', 'reinstall', 'download', 'info', 'urls']:
		install_operations_family(operation, args, local_list, remote_list, persistent_list)
		sys.exit()
	
	if operation in ['install-new', 'download-new', 'info-new', 'urls-new']:
		names = pkgs_in_state(persistent_list, [slackroll_state_new])
		names.sort(cmp=pkg_name_cmp)
		if len(names) == 0:
			print 'No new packages'
			sys.exit()
		opname = operation.replace('-new', '')
		install_operations_family(opname, names, local_list, remote_list, persistent_list)
		sys.exit()
	
	if operation in ['install-path', 'download-path', 'info-path', 'urls-path', 'remove-path']:
		all_regexes = '|'.join('(%s)' % x for x in args)
		try:
			regexp = re.compile(all_regexes)
		except re.error:
			sys.exit('ERROR: invalid regular expression')

		matching_pkgs = [x for x in concat([remote_list[x] for x in remote_list]) if regexp.search(x.path) is not None]

		if operation == 'remove-path': # Filter out packages not present in local system
			matching_pkgs = [x for x in matching_pkgs if pkg_in_map(x, local_list)]

		if len(matching_pkgs) == 0:
			print 'No matching packages'
			sys.exit()

		matching_pkgs.sort()
		if operation == 'remove-path':
			if maybe_print_new_warning(persistent_list) or maybe_print_outdated_warning(persistent_list):
				confirm_continue()
			remove_pkgs([x.local() for x in matching_pkgs])
		else:
			opname = operation.replace('-path', '')
			archivenames = [x.archivename for x in matching_pkgs]
			install_operations_family(opname, archivenames, local_list, remote_list, persistent_list)

		sys.exit()
	
	if operation == 'local-info':
		verify_local_names(args, local_list)
		interceptor = SlackRollOutputInterceptor()
		try:
			print '\n'.join(file(x.fullname, 'r').read() for x in concat(local_list[pkg] for pkg in args))
		except (IOError, OSError), err:
			sys.exit('ERROR: %s' % err)
		interceptor.stop()
		sys.exit()

	if operation == 'install-foreign':
		# Verify readable files
		bad_files = [x for x in args if not is_readable_file(x)]
		if len(bad_files) > 0:
			sys.stderr.write('ERROR: the following items are not readable files:\n')
			sys.stderr.write(''.join('ERROR:    %s\n' % x for x in bad_files))
			sys.exit(slackroll_exit_failure)

		# Verify and get package names
		try:
			pkgs = [pkg_from_str(x) for x in args]
		except SlackRollError, err:
			sys.exit('ERROR: %s' % err)

		# The packages must not be present in persistent list or be foreign already
		bad_pkgs = [x for x in pkgs if x.name in persistent_list and persistent_list[x.name] != slackroll_state_foreign]
		if len(bad_pkgs) > 0:
			sys.stderr.write('ERROR: the following packages are known and not foreign\n')
			sys.stderr.write(''.join('ERROR:    %s\n' % x.name for x in bad_pkgs))
			sys.exit(slackroll_exit_failure)

		# Get .new files from old packages
		prev_dotnew = extract_dotnew_files(concat([local_list[x.name] for x in pkgs if x.name in local_list]))

		# Install and mark
		for arg in args:
			upgrade_or_install(arg, False)
		for pkg in pkgs:
			persistent_list[pkg.name] = slackroll_state_foreign
			persistent_list.sync()

		# Go over .new files
		cur_dotnew = extract_dotnew_files([x.local() for x in pkgs])
		handle_dotnew_files_both(prev_dotnew, cur_dotnew)
		sys.exit()
	
	if operation == 'replace':
		if maybe_print_key_pkg_warning(persistent_list):
			confirm_continue()

		# Verify package names
		for name in args:
			if name not in persistent_list:
				if may_be_full_version(name):
					sys.stderr.write('WARNING: %s looks like an unexpected full version\n' % name)
				sys.exit('ERROR: no package named %s' % name)

		unavpkg = args[0]
		newpkg = args[1]

		# Verify package conditions
		if persistent_list[unavpkg] != slackroll_state_unavailable:
			sys.exit('ERROR: %s must be in the "unavailable" state' % unavpkg)
		if persistent_list[newpkg] != slackroll_state_new:
			sys.exit('ERROR: %s must be in the "new" state' % newpkg)

		# Choose specific package
		if len(remote_list[newpkg]) != 1:
			chosen_new = choose_pkg(remote_list[newpkg])
		else:
			chosen_new = remote_list[newpkg][0]

		# Download
		if not package_in_cache(chosen_new):
			filename_new = download_verify(get_mirror(), chosen_new)
		else:
			filename_new = os.path.join(slackroll_pkgs_dir, chosen_new.archivename)

		# upgradepkg
		prev_dotnew = extract_dotnew_files(local_list[unavpkg])
		replace_pkg(unavpkg, filename_new)
		cur_dotnew = extract_dotnew_files([chosen_new.local()])
		handle_dotnew_files_both(prev_dotnew, cur_dotnew)

		sys.exit()

	if operation in ['remove', 'remove-unavailable']:
		if maybe_print_new_warning(persistent_list) or maybe_print_outdated_warning(persistent_list):
			confirm_continue()

		if operation == 'remove':
			verify_local_names(args, local_list)
			final_args = args
		else: # remove-unavailable
			final_args = pkgs_in_state(persistent_list, [slackroll_state_unavailable])

		if len(final_args) == 0:
			print 'No packages to remove'
			sys.exit()

		to_be_removed = []
		if operation == 'remove':
			for name in final_args:
				candidates = local_list[name]
				if len(candidates) == 1:
					to_be_removed.append(candidates[0])
					continue
				chosen = choose_pkg(candidates)
				if chosen is not None:
					to_be_removed.append(chosen)
		else: # remove-unavailable
			for name in final_args:
				to_be_removed.extend(local_list[name])

		remove_pkgs(to_be_removed)
		sys.exit()

	if operation == 'name-search':
		all_regexes = '|'.join('(%s)' % x for x in args)
		try:
			regexp = re.compile(all_regexes)
		except re.error:
			sys.exit('ERROR: invalid regular expression')

		plist_subset = dict([(x, persistent_list[x]) for x in persistent_list if regexp.search(x) is not None])
		print_in_states_or(slackroll_all_states, plist_subset, 'Matching packages:', 'No matching packages found', True)
		sys.exit()
	
	if operation == 'path-search':
		all_regexes = '|'.join('(%s)' % x for x in args)
		try:
			regexp = re.compile(all_regexes)
		except re.error:
			sys.exit('ERROR: invalid regular expression')

		matching_fullnames = [x.fullname for x in concat([remote_list[x] for x in remote_list]) if regexp.search(x.path) is not None]
		print_list_or(matching_fullnames, 'Matching packages:', 'No matching packages found')
		sys.exit()
	
except (KeyboardInterrupt, IOError, EOFError), error:
	if isinstance(error, KeyboardInterrupt):
		sys.stderr.write('\nProgram aborted by user\n')
	if persistent_list is not None:
		persistent_list.close()
	sys.exit(slackroll_exit_failure)

except IndexError:
	sys.stderr.write('ERROR: no operation given\n')
	sys.stderr.write('Use "help" operation to get a list\n')
	sys.exit(slackroll_exit_failure)
